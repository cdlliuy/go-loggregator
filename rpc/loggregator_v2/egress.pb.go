// Code generated by protoc-gen-go. DO NOT EDIT.
// source: egress.proto

/*
Package loggregator_v2 is a generated protocol buffer package.

It is generated from these files:
	egress.proto
	envelope.proto
	ingress.proto

It has these top-level messages:
	EgressRequest
	EgressBatchRequest
	Selector
	LogSelector
	GaugeSelector
	CounterSelector
	TimerSelector
	EventSelector
	Envelope
	EnvelopeBatch
	Value
	Log
	Counter
	Gauge
	GaugeValue
	Timer
	Event
	IngressResponse
	BatchSenderResponse
	SendResponse
*/
package loggregator_v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EgressRequest struct {
	// shard_id instructs Loggregator to shard envelopes between other
	// subscriptions with the same shard_id. Loggregator will do its best to
	// split the load evenly between subscriptions with the same shard_id.
	ShardId string `protobuf:"bytes,1,opt,name=shard_id,json=shardId" json:"shard_id,omitempty"`
	// TODO: This can be removed once selector has been around long enough.
	LegacySelector *Selector `protobuf:"bytes,2,opt,name=legacy_selector,json=legacySelector" json:"legacy_selector,omitempty"`
	// selector is the preferred (over legacy_selector) mechanism to select
	// what envelope types the subscription wants. If there are no selectors
	// given, no data will be sent.
	Selectors []*Selector `protobuf:"bytes,4,rep,name=selectors" json:"selectors,omitempty"`
	// TODO: This can be removed once the envelope.deprecated_tags is removed.
	UsePreferredTags bool `protobuf:"varint,3,opt,name=use_preferred_tags,json=usePreferredTags" json:"use_preferred_tags,omitempty"`
}

func (m *EgressRequest) Reset()                    { *m = EgressRequest{} }
func (m *EgressRequest) String() string            { return proto.CompactTextString(m) }
func (*EgressRequest) ProtoMessage()               {}
func (*EgressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EgressRequest) GetShardId() string {
	if m != nil {
		return m.ShardId
	}
	return ""
}

func (m *EgressRequest) GetLegacySelector() *Selector {
	if m != nil {
		return m.LegacySelector
	}
	return nil
}

func (m *EgressRequest) GetSelectors() []*Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *EgressRequest) GetUsePreferredTags() bool {
	if m != nil {
		return m.UsePreferredTags
	}
	return false
}

type EgressBatchRequest struct {
	// shard_id instructs Loggregator to shard envelopes between other
	// subscriptions with the same shard_id. Loggregator will do its best to
	// split the load evenly between subscriptions with the same shard_id.
	ShardId string `protobuf:"bytes,1,opt,name=shard_id,json=shardId" json:"shard_id,omitempty"`
	// TODO: This can be removed once selector has been around long enough.
	LegacySelector *Selector `protobuf:"bytes,2,opt,name=legacy_selector,json=legacySelector" json:"legacy_selector,omitempty"`
	// selector is the preferred (over legacy_selector) mechanism to select
	// what envelope types the subscription wants. If there are no selectors
	// given, no data will be sent.
	Selectors []*Selector `protobuf:"bytes,4,rep,name=selectors" json:"selectors,omitempty"`
	// TODO: This can be removed once the envelope.deprecated_tags is removed.
	UsePreferredTags bool `protobuf:"varint,3,opt,name=use_preferred_tags,json=usePreferredTags" json:"use_preferred_tags,omitempty"`
}

func (m *EgressBatchRequest) Reset()                    { *m = EgressBatchRequest{} }
func (m *EgressBatchRequest) String() string            { return proto.CompactTextString(m) }
func (*EgressBatchRequest) ProtoMessage()               {}
func (*EgressBatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EgressBatchRequest) GetShardId() string {
	if m != nil {
		return m.ShardId
	}
	return ""
}

func (m *EgressBatchRequest) GetLegacySelector() *Selector {
	if m != nil {
		return m.LegacySelector
	}
	return nil
}

func (m *EgressBatchRequest) GetSelectors() []*Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *EgressBatchRequest) GetUsePreferredTags() bool {
	if m != nil {
		return m.UsePreferredTags
	}
	return false
}

// Selector instructs Loggregator to only send envelopes that match the given
// criteria.
type Selector struct {
	SourceId string `protobuf:"bytes,1,opt,name=source_id,json=sourceId" json:"source_id,omitempty"`
	// Types that are valid to be assigned to Message:
	//	*Selector_Log
	//	*Selector_Counter
	//	*Selector_Gauge
	//	*Selector_Timer
	//	*Selector_Event
	Message isSelector_Message `protobuf_oneof:"Message"`
}

func (m *Selector) Reset()                    { *m = Selector{} }
func (m *Selector) String() string            { return proto.CompactTextString(m) }
func (*Selector) ProtoMessage()               {}
func (*Selector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isSelector_Message interface {
	isSelector_Message()
}

type Selector_Log struct {
	Log *LogSelector `protobuf:"bytes,2,opt,name=log,oneof"`
}
type Selector_Counter struct {
	Counter *CounterSelector `protobuf:"bytes,3,opt,name=counter,oneof"`
}
type Selector_Gauge struct {
	Gauge *GaugeSelector `protobuf:"bytes,4,opt,name=gauge,oneof"`
}
type Selector_Timer struct {
	Timer *TimerSelector `protobuf:"bytes,5,opt,name=timer,oneof"`
}
type Selector_Event struct {
	Event *EventSelector `protobuf:"bytes,6,opt,name=event,oneof"`
}

func (*Selector_Log) isSelector_Message()     {}
func (*Selector_Counter) isSelector_Message() {}
func (*Selector_Gauge) isSelector_Message()   {}
func (*Selector_Timer) isSelector_Message()   {}
func (*Selector_Event) isSelector_Message()   {}

func (m *Selector) GetMessage() isSelector_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Selector) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *Selector) GetLog() *LogSelector {
	if x, ok := m.GetMessage().(*Selector_Log); ok {
		return x.Log
	}
	return nil
}

func (m *Selector) GetCounter() *CounterSelector {
	if x, ok := m.GetMessage().(*Selector_Counter); ok {
		return x.Counter
	}
	return nil
}

func (m *Selector) GetGauge() *GaugeSelector {
	if x, ok := m.GetMessage().(*Selector_Gauge); ok {
		return x.Gauge
	}
	return nil
}

func (m *Selector) GetTimer() *TimerSelector {
	if x, ok := m.GetMessage().(*Selector_Timer); ok {
		return x.Timer
	}
	return nil
}

func (m *Selector) GetEvent() *EventSelector {
	if x, ok := m.GetMessage().(*Selector_Event); ok {
		return x.Event
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Selector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Selector_OneofMarshaler, _Selector_OneofUnmarshaler, _Selector_OneofSizer, []interface{}{
		(*Selector_Log)(nil),
		(*Selector_Counter)(nil),
		(*Selector_Gauge)(nil),
		(*Selector_Timer)(nil),
		(*Selector_Event)(nil),
	}
}

func _Selector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Selector)
	// Message
	switch x := m.Message.(type) {
	case *Selector_Log:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case *Selector_Counter:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Counter); err != nil {
			return err
		}
	case *Selector_Gauge:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Gauge); err != nil {
			return err
		}
	case *Selector_Timer:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Timer); err != nil {
			return err
		}
	case *Selector_Event:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Event); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Selector.Message has unexpected type %T", x)
	}
	return nil
}

func _Selector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Selector)
	switch tag {
	case 2: // Message.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Log{msg}
		return true, err
	case 3: // Message.counter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CounterSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Counter{msg}
		return true, err
	case 4: // Message.gauge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GaugeSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Gauge{msg}
		return true, err
	case 5: // Message.timer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimerSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Timer{msg}
		return true, err
	case 6: // Message.event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EventSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Event{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Selector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Selector)
	// Message
	switch x := m.Message.(type) {
	case *Selector_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Counter:
		s := proto.Size(x.Counter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Gauge:
		s := proto.Size(x.Gauge)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Timer:
		s := proto.Size(x.Timer)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Event:
		s := proto.Size(x.Event)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// LogSelector instructs Loggregator to egress Log envelopes to the given
// subscription.
type LogSelector struct {
}

func (m *LogSelector) Reset()                    { *m = LogSelector{} }
func (m *LogSelector) String() string            { return proto.CompactTextString(m) }
func (*LogSelector) ProtoMessage()               {}
func (*LogSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// GaugeSelector instructs Loggregator to egress Gauge envelopes to the
// given subscription.
type GaugeSelector struct {
	// Any egress Gauge envelope must consist of the given names.
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *GaugeSelector) Reset()                    { *m = GaugeSelector{} }
func (m *GaugeSelector) String() string            { return proto.CompactTextString(m) }
func (*GaugeSelector) ProtoMessage()               {}
func (*GaugeSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GaugeSelector) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// CounterSelector instructs Loggregator to egress Counter envelopes to the
// given subscription.
type CounterSelector struct {
	// Any egress Counter envelope must have the given name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *CounterSelector) Reset()                    { *m = CounterSelector{} }
func (m *CounterSelector) String() string            { return proto.CompactTextString(m) }
func (*CounterSelector) ProtoMessage()               {}
func (*CounterSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CounterSelector) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// TimerSelector instructs Loggregator to egress Timer envelopes to the given
// subscription.
type TimerSelector struct {
}

func (m *TimerSelector) Reset()                    { *m = TimerSelector{} }
func (m *TimerSelector) String() string            { return proto.CompactTextString(m) }
func (*TimerSelector) ProtoMessage()               {}
func (*TimerSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// EventSelector instructs Loggregator to egress Event envelopes to the given
// subscription.
type EventSelector struct {
}

func (m *EventSelector) Reset()                    { *m = EventSelector{} }
func (m *EventSelector) String() string            { return proto.CompactTextString(m) }
func (*EventSelector) ProtoMessage()               {}
func (*EventSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*EgressRequest)(nil), "loggregator.v2.EgressRequest")
	proto.RegisterType((*EgressBatchRequest)(nil), "loggregator.v2.EgressBatchRequest")
	proto.RegisterType((*Selector)(nil), "loggregator.v2.Selector")
	proto.RegisterType((*LogSelector)(nil), "loggregator.v2.LogSelector")
	proto.RegisterType((*GaugeSelector)(nil), "loggregator.v2.GaugeSelector")
	proto.RegisterType((*CounterSelector)(nil), "loggregator.v2.CounterSelector")
	proto.RegisterType((*TimerSelector)(nil), "loggregator.v2.TimerSelector")
	proto.RegisterType((*EventSelector)(nil), "loggregator.v2.EventSelector")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Egress service

type EgressClient interface {
	Receiver(ctx context.Context, in *EgressRequest, opts ...grpc.CallOption) (Egress_ReceiverClient, error)
	BatchedReceiver(ctx context.Context, in *EgressBatchRequest, opts ...grpc.CallOption) (Egress_BatchedReceiverClient, error)
}

type egressClient struct {
	cc *grpc.ClientConn
}

func NewEgressClient(cc *grpc.ClientConn) EgressClient {
	return &egressClient{cc}
}

func (c *egressClient) Receiver(ctx context.Context, in *EgressRequest, opts ...grpc.CallOption) (Egress_ReceiverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Egress_serviceDesc.Streams[0], c.cc, "/loggregator.v2.Egress/Receiver", opts...)
	if err != nil {
		return nil, err
	}
	x := &egressReceiverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Egress_ReceiverClient interface {
	Recv() (*Envelope, error)
	grpc.ClientStream
}

type egressReceiverClient struct {
	grpc.ClientStream
}

func (x *egressReceiverClient) Recv() (*Envelope, error) {
	m := new(Envelope)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *egressClient) BatchedReceiver(ctx context.Context, in *EgressBatchRequest, opts ...grpc.CallOption) (Egress_BatchedReceiverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Egress_serviceDesc.Streams[1], c.cc, "/loggregator.v2.Egress/BatchedReceiver", opts...)
	if err != nil {
		return nil, err
	}
	x := &egressBatchedReceiverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Egress_BatchedReceiverClient interface {
	Recv() (*EnvelopeBatch, error)
	grpc.ClientStream
}

type egressBatchedReceiverClient struct {
	grpc.ClientStream
}

func (x *egressBatchedReceiverClient) Recv() (*EnvelopeBatch, error) {
	m := new(EnvelopeBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Egress service

type EgressServer interface {
	Receiver(*EgressRequest, Egress_ReceiverServer) error
	BatchedReceiver(*EgressBatchRequest, Egress_BatchedReceiverServer) error
}

func RegisterEgressServer(s *grpc.Server, srv EgressServer) {
	s.RegisterService(&_Egress_serviceDesc, srv)
}

func _Egress_Receiver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EgressRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EgressServer).Receiver(m, &egressReceiverServer{stream})
}

type Egress_ReceiverServer interface {
	Send(*Envelope) error
	grpc.ServerStream
}

type egressReceiverServer struct {
	grpc.ServerStream
}

func (x *egressReceiverServer) Send(m *Envelope) error {
	return x.ServerStream.SendMsg(m)
}

func _Egress_BatchedReceiver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EgressBatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EgressServer).BatchedReceiver(m, &egressBatchedReceiverServer{stream})
}

type Egress_BatchedReceiverServer interface {
	Send(*EnvelopeBatch) error
	grpc.ServerStream
}

type egressBatchedReceiverServer struct {
	grpc.ServerStream
}

func (x *egressBatchedReceiverServer) Send(m *EnvelopeBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Egress_serviceDesc = grpc.ServiceDesc{
	ServiceName: "loggregator.v2.Egress",
	HandlerType: (*EgressServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Receiver",
			Handler:       _Egress_Receiver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BatchedReceiver",
			Handler:       _Egress_BatchedReceiver_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "egress.proto",
}

func init() { proto.RegisterFile("egress.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 475 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x94, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0xc7, 0x97, 0xf5, 0x2b, 0x39, 0xa5, 0x2d, 0x58, 0x5c, 0x98, 0x4e, 0xd3, 0xa2, 0x48, 0x93,
	0x7a, 0x81, 0x02, 0x2a, 0x1f, 0x37, 0x5c, 0x51, 0x54, 0x8d, 0x49, 0x43, 0x42, 0x61, 0x17, 0xdc,
	0x55, 0x26, 0x39, 0xf3, 0x2a, 0x65, 0x71, 0xb1, 0x9d, 0x4a, 0x7b, 0x26, 0x9e, 0x83, 0x27, 0xe0,
	0x86, 0xc7, 0x41, 0xb6, 0x9b, 0x35, 0x4d, 0x0b, 0x0f, 0xc0, 0x5d, 0x8e, 0xff, 0xff, 0xdf, 0xf9,
	0xb0, 0x7c, 0x02, 0x8f, 0x90, 0x4b, 0x54, 0x2a, 0x5e, 0x49, 0xa1, 0x05, 0x19, 0xe6, 0x82, 0x73,
	0x89, 0x9c, 0x69, 0x21, 0xe3, 0xf5, 0x74, 0x3c, 0xc4, 0x62, 0x8d, 0xb9, 0x58, 0xa1, 0xd3, 0xa3,
	0x5f, 0x1e, 0x0c, 0xe6, 0x16, 0x48, 0xf0, 0x7b, 0x89, 0x4a, 0x93, 0x67, 0xe0, 0xab, 0x5b, 0x26,
	0xb3, 0xc5, 0x32, 0xa3, 0x5e, 0xe8, 0x4d, 0x82, 0xa4, 0x67, 0xe3, 0xcb, 0x8c, 0xbc, 0x87, 0x51,
	0x8e, 0x9c, 0xa5, 0xf7, 0x0b, 0x85, 0x39, 0xa6, 0x5a, 0x48, 0x7a, 0x1c, 0x7a, 0x93, 0xfe, 0x94,
	0xc6, 0xbb, 0x65, 0xe2, 0x2f, 0x1b, 0x3d, 0x19, 0x3a, 0xa0, 0x8a, 0xc9, 0x5b, 0x08, 0x2a, 0x56,
	0xd1, 0x76, 0xd8, 0xfa, 0x27, 0xbc, 0xb5, 0x92, 0xe7, 0x40, 0x4a, 0x85, 0x8b, 0x95, 0xc4, 0x1b,
	0x94, 0x12, 0xb3, 0x85, 0x66, 0x5c, 0xd1, 0x56, 0xe8, 0x4d, 0xfc, 0xe4, 0x71, 0xa9, 0xf0, 0x73,
	0x25, 0x5c, 0x33, 0xae, 0xa2, 0xdf, 0x1e, 0x10, 0x37, 0xd5, 0x8c, 0xe9, 0xf4, 0xf6, 0x7f, 0x1a,
	0xed, 0xe7, 0x31, 0xf8, 0x0f, 0x25, 0x4f, 0x20, 0x50, 0xa2, 0x94, 0x29, 0x6e, 0x27, 0xf2, 0xdd,
	0xc1, 0x65, 0x46, 0x5e, 0x40, 0x2b, 0x17, 0x7c, 0x33, 0xc6, 0x49, 0xb3, 0x93, 0x2b, 0xc1, 0xab,
	0x34, 0x1f, 0x8f, 0x12, 0xe3, 0x24, 0xef, 0xa0, 0x97, 0x8a, 0xb2, 0xd0, 0x28, 0x6d, 0xf5, 0xfe,
	0xf4, 0xac, 0x09, 0x7d, 0x70, 0x72, 0x0d, 0xac, 0x08, 0xf2, 0x06, 0x3a, 0x9c, 0x95, 0x1c, 0x69,
	0xdb, 0xa2, 0xa7, 0x4d, 0xf4, 0xc2, 0x88, 0x35, 0xd0, 0xb9, 0x0d, 0xa6, 0x97, 0x77, 0x28, 0x69,
	0xe7, 0x30, 0x76, 0x6d, 0xc4, 0x3a, 0x66, 0xdd, 0x06, 0xc3, 0x35, 0x16, 0x9a, 0x76, 0x0f, 0x63,
	0x73, 0x23, 0xd6, 0x31, 0xeb, 0x9e, 0x05, 0xd0, 0xfb, 0x84, 0x4a, 0x31, 0x8e, 0xd1, 0x00, 0xfa,
	0xb5, 0x2b, 0x88, 0xce, 0x61, 0xb0, 0xd3, 0x21, 0x79, 0x0a, 0x9d, 0x82, 0xdd, 0xa1, 0xa2, 0x5e,
	0xd8, 0x9a, 0x04, 0x89, 0x0b, 0xa2, 0x73, 0x18, 0x35, 0xee, 0x80, 0x10, 0x68, 0x1b, 0x6d, 0x73,
	0xfd, 0xf6, 0x3b, 0x1a, 0xc1, 0x60, 0xa7, 0x71, 0x73, 0xb0, 0xd3, 0xd2, 0xf4, 0x87, 0x07, 0x5d,
	0xf7, 0x42, 0xc9, 0x05, 0xf8, 0x09, 0xa6, 0xb8, 0x5c, 0xa3, 0x24, 0xfb, 0x83, 0xd4, 0x77, 0x73,
	0xbc, 0xf7, 0x9e, 0xe6, 0x9b, 0x6d, 0x8e, 0x8e, 0x5e, 0x7a, 0xe4, 0x2b, 0x8c, 0xec, 0x73, 0xc7,
	0xec, 0x21, 0x5f, 0x74, 0x38, 0x5f, 0x7d, 0x2b, 0xc6, 0xa7, 0x7f, 0x4b, 0x6a, 0x5d, 0x26, 0xf3,
	0xec, 0x35, 0x9c, 0x09, 0xc9, 0xe3, 0x34, 0x17, 0x65, 0x76, 0x23, 0xca, 0x22, 0x93, 0xf7, 0x0d,
	0x68, 0xf6, 0xe4, 0x6a, 0x1b, 0xbb, 0x22, 0xdf, 0xba, 0xf6, 0x17, 0xf3, 0xea, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xc1, 0xcb, 0x29, 0xc6, 0x92, 0x04, 0x00, 0x00,
}
